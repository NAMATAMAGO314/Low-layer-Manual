# GPIOをやろう
## GPIOとは?
我々が今からやっていくのはGPIOです。GPIOとは、制御方法の中でも比較的簡単なものです。電圧の高い状態(High)と、電圧の低い状態(Low)をそれぞれ1と0に見立てて、LEDのON・OFFなどを行う制御方法です。言葉で説明するより実際に手を動かしたほうがわかると思うので、早速やっていきましょう。  
## PIN設定とコーディング  
まずは、STM32CubeIDE(めんどくさいのでこれ以降はSTM呼びでいきます)を起動して、PIN設定の画面を開きます。初回の時点から何もいじっていなければ起動後に勝手に設定画面になっているはずです。もしもコードの画面になっている場合は、下の画像の一番下にある、**test_play.ioc** と書いてあるところをダブルクリックすると開けます。  

![a](s_2025-08-29_174240.png)  

下のようになればOKです。 

![alt text](rimage-0.png)  

PIN設定をします。今回は、基板についている3つのLED1～3を順番に光らせることを最終目的とします。著者が今回使う基板はLED1～3に対応するPIN(つまり、それぞれのLEDに電圧を加えたりするためのPIN)は、それぞれPC10,PC11,PC12だったので、その3つのPINを設定していきます。  
ところで、基板についているLEDに対応するPINは基板によって違います。基板を凝視すればわからないこともないのですが、それはめんどくさいので **回路図** を見ましょう。  
回路図とは、ロボコンの回路班(著者の時代はそう呼ばれている班)が作ってくれる、その基板のどこのPINが何に対応しているかが書いてある図です。  

![alt text](shot.png)  

これはその回路図を拡大したものです。左にはPA0やPC10などのPINと、GPIOやLEDなどの情報が書いてあります。親切な人は右側の青文字のように、どのPINがどこに対応しているのかまとめてくれたりします。  
左側をよく見ると、LED1や、CAN1_RXなど、先端がとがってる方が黄色の四角側に向いてるものと、CAN1_TXなどの尖っているのが外側に向いてるものがあります。これは、入力と出力の関係を表しています。わかりやすく言うなら、 **こちら(マイコン)側から出力を決めるときは外側を向いていて、何かが送られてくるとき(マイコンが受信するとき)は内側を向いている。** ということです。  
...実は著者の回路図は誤りがあります。LED1～3のところを見ると、内側を向いています。しかし、LEDの出力は外部から勝手に決まるわけではなく、もちろん我々が制御するので外側を向いているべきです。回路図の作成者はあとで叱っておきます。PINのことに関して大体のことはわかってきたのでPIN設定の画面に戻りましょう。   
回路図に従い、PC10と書かれている長方形をクリックすると、このようにいろいろ出てきます。  

![alt text](rimage-1.png)  

これは、このPINに備わっている機能の一覧で、たった一つのPINでもいろいろなことができるのが分かります。この一覧から、今回はGPIO_Outputをクリックしてください。これにより、今回このPINが担う機能が決定しました。  
なぜGPIO_Outputを選んだかというと、先ほども言ったとおり、今回はこちら側から電圧を制御してLEDを光らせるので、われわれが"出力する"つまりはOutputというわけです。GPIO_Outputを押すと、下の画像のように四角が緑色になります。これからいろんなPINを設定していくと、緑ではなく黄色になる場合がありますが、それは今後話します。ちなみに、設定したPINの長方形をクリックして一番上のReset_Stateをおすと設定がリセットできます。  
画面左にあるCategoriesから、System_Coreをクリックすると、下の画像のようにDMAや、GPIOなどが出てきます。  

![alt text](rimage-2.png)  

GPIOをクリックして、下の画像にある、黒の三角を押すと隠れていた設定画面が出てきます。 

![alt text](rimage-3.png)  

下の画像のように、SYS、RCC、USART、GPIOなどがあります。これは、System_Core全体の設定選択画面です。今回はGPIOを設定するので、GPIOを選択します。ほかの機能は今後説明していくので、今はそのままで大丈夫です。  

![alt text](rimage-4.png)  

今回PIN設定したPC10の欄の一番右の欄は、Modifiedの欄になっています。  
これは、何か設定を変更したときに、その目印としての役割をします。System_Coreでは、何か設定を変えると勝手にチェックが付くので何もしないで大丈夫です。次回やる、GPIOの進化系のPWMでは自分でチェックを入れることができます。あくまでもただの目印であって制御には何も影響しないので、次回こいつが出てきたときは、チェックを入れても入れなくてもどちらでも構いません。心配ご無用です。  
それではここでPINの設定はおしまいにして、クロック設定に入ります。  
画面の上の方にあるPinout&Configurationの隣にあるClock Configurationをクリックすると、下の画像のような画面が出てきます。  

![alt text](rimage-5.png)  

これは、このマイコンで行う制御の、タイマーや周波数の大本の設定画面です。画面左下にあるHSEおよびHSIは、それぞれ、
- High Speed Internal oscillator(内部水晶振動子)
- High Speed External oscillator(外部水晶振動子)  

のことです。外部のほうが内部の物よりも精度がいいと言われているので、基本的にはHSEを選択しておきましょう。  

![alt text](rimage-6.png)  

下の画像のように、画面左のInput frequencyを20に、PLL Source Mux の右にあるPLLMを/10にしておきましょう。  

![alt text](image-7.png)

画面右端にあるAPB1 Timerclocksを見ると、デフォルトでは84になっていますが、先ほどHSEを選択したので42になっているはずです(下の画像はHSE設定前)。  

![alt text](rimage-7.png)  

ここを選択して、50に設定し、Enterを押すと下の画像のようにほかの値が勝手に切り替わります。これは、HSE設定&APB1が最終的に50MHzになるように設定したため、計算結果がそうなるようにほかの値が自動的に調整されたということです。なぜ50に設定するのかは次回のPWMの時にお話しします。  

![alt text](rimage-8.png)  

先ほどのPIN設定と同様に、PC11、PC12も設定し、 **Ctrl + s** で保存すると、下の画像のようにDo you want to generate Code?つまり、「コードを生成しますか?」と聞かれます。我々が設定したPIN設定とクロック設定に対応したコードを生成するかどうかということです。下にあるRemember my decisionは、Ctrl + sを押されたら次からはDo you want to generate Code?と聞かずに自動で保存するかどうかを聞かれています。これについてはとある事情があるため、いまはチェックを入れないでください。次回これについてお話しします。 

![alt text](rimage-9.png)  

Do you want to generate Code?の画面で、Remember my decisionにチェックを入れずに右下のYesを押すと、下の画像の様なものが出てきます。これは、コードの編集画面を表示するかどうかを聞いています。Yesを押すとコーディング画面に、Noを押すと、PIN設定を保存し、それに応じたコードを生成し、コーディング画面には移動せずにPIN設定の画面のままになります。どちらを押そうが結局はコーディング画面を後で開けるのでYesを押しましょう。Remember my decisionについては先ほどと同じような感じです。  

![alt text](rimage-10.png)  
## コーディングをしよう  
Yesを押してしばらく経つと、下の画像のように、コーディング画面が出てきます。いよいよコードを書いていきます。  

![alt text](zimage.png)  

ここからは、GPIOで基板のLED1～3を光らせるコードを書いていきます。C言語及びC++で書いていきますが、C言語の知識がないよ～(;´д｀)トホホという方は、下に載せておく外部リンクに飛んでお勉強してから戻ってきてください。成長したあなたをお待ちしております。 

- [苦しんで覚えるC言語](https://9cguide.appspot.com/index.html)  
C言語を詳しく学べるサイトです。  
- [C++入門 AtCoder Programming Guide for beginners (APG4b)](https://atcoder.jp/contests/apg4b?_gl=1*11he24b*_ga*MTQ0MTAzNzY2OC4xNzU1ODQzNDY0*_ga_RC512FD18N*czE3NTY3MDE5OTAkbzQkZzEkdDE3NTY3MDE5OTMkajU3JGwwJGgw)  
競技プログラミング用のサイトで提供されている学習サイトです。因みに著者はこのサイトでC言語を学びました。  

さて、いよいよコーディングをするわけですが、下の画像のように、画面左にあるProject Explorerを見てください。  

![alt text](zimage-1.png)  

ここには、現在自分が持っているプロジェクトの一覧が出ています。  
フォルダ名の横にある、「>」こんな感じのマークを押すと、その中にあるフォルダ一覧が出てきます。先ほどの画像のように、test_play→Core→Srcとクリックしていくと、Srcの真下にmain.cという名前のファイルがあります。  「.c」というのは、このファイルがC言語で書いてあるということを表しています。ここを右クリックすると、下の画像のように、ファイルに対する操作が出てきます。  
このうち、Renameをクリックすると、New nameと出てくるので、main.cを、main.cppに書き換えて、OKを押してください。なぜ名前を変えるのかは次回お話しします。

![alt text](zimage-2.png)![alt text](zimage-3.png)

main.cppに変更できたら、いよいよ書いていきます と、言いたいところですが、もう少しだけお話することがあります。ごめんなさい。  
下の画像のように、先ほどのPIN設定により自動生成されたコードがたくさんあります。見慣れない関数もあると思いますが、HAL_で始まっているものはすべて、HALライブラリで用意されている専用の関数です。  

![alt text](image.png)  

### HALライブラリとは
HALライブラリとは、Hardware Abstraction Layerの略で、STマイクロエレクトロニクスが提供する専用の関数です。これからたくさん使っていくので、どんどん覚えていきましょう。ただ、最初のうちは何もわからないでしょうから、Qiitaで調べたり、いろんなところからコピペしたりして大丈夫です。AIに聞くのも一つの手ですが、ごくまれに一時代前の関数を出してきたりするので注意が必要です。  
先ほどの画像を見ると分かりますが、このファイルにはところどころにUSER CODE BEGINや、USER CODE ENDと書いてあります。これは、BEGINとENDに挟まれたところが我々がコードを書くところだということです。もしもれらに挟まれていないところにコードを書くと、マイコンにコードを書きこむときに自分の書いたコードが消えてしまいます。十分に気をつけましょう。  
## 今度こそコーディングをしよう
大変お待たせいたしました。今度こそコーディングです。main.cppを開き、102行目あたりにあるwhile文の辺りを見てください。 

![alt text](image-1.png)  

上の画像のように、/* USER CODE BEGIN 3 */と書かれた部分があるので、Shift + Enterで改行し、コードを書きます。今回はLEDを光らせ続けるので、永遠に繰り返すwhileの中に書きます。  
GPIOを使い、PC10,11,12の電圧をそれぞれHighにすることでそれぞれのLEDが光るので、こちら側からPINにかかる電圧を制御します。  
そのために使う関数がコチラ  
`HAL_GPIO_WritePin(GPIO〇, GPIO_PIN_n,GPIO_PIN_SET)`  
です。
関数名がHAL_から始まっているので、この関数はHALライブラリの関数です。その名前の通り、GPIOPINに書き込むことができます。  
実際にどのPINに書き込むかは、(GPIO〇, GPIO_PIN_n,GPIO_SET)の部分で決めます。今回はPC10,11,12なので、`HAL_GPIO_WritePin(GPIOC, GPIO_PIN_10,GPIO_PIN_SET)`のように書きます。GPIO_PIN_SETの部分をGPIO_PIN_RESETにすれば、電圧はLowとなり、LEDを消すことができます。  
順番に光らせるといいましたが、このままだとPC10に対応するLED1がただ光り続けるだけになってしまうので、少しの間光り続ける必要があります。そのために使う関数がコチラ  
`HAL_Delay(n)`  
です。これもHALライブラリの関数ですね。nに待機する時間を入れることでその時間の間現在の状態を維持し続けてくれます。単位はnミリ秒です。今回は`HAL_Delay(500)`としておきましょう。0.5秒間光り続けてくれます。  
関数の紹介はここまでとして、main.cppに書きましょう。PC10点灯→0.5秒待機→消灯→PC11点灯→0.5秒待機→消灯→PC12点灯→0.5秒待機→消灯→PC10点灯...と繰り返すようにしたいと思います。下の画像のように書いてください。  

![alt text](image-2.png)  

WritePinでSET(点灯)し、Delayで0.5秒待機、WritePinで消灯...という風に続いているのがわかると思います。Ctrl + sをして、Build(ビルド)をします。  
ビルドとは、書いたコードが構文的なエラーなどがないかどうかチェックしてくれる機能です。下の画像のように、画面上部のかなづちマークを押すとビルドを開始します。  

![alt text](image-3.png)  

何処にもラーがなく、ビルドが無事成功すると、下の画像のように「0 errors, 0 warnings.」と表示されます。 

![alt text](image-4.png)  

稀に、構文エラーなどでエラーが出る場合があります。その場合は、ほとんどがセミコロン「;」のつけ忘れや、関数名の間違いです。これらに当てはまらないエラーの場合は、自動生成されたコードのどこかを消してしまったりしている場合があります。エラー文をそのままAIにコピペすると、エラー内容と対処法を出してくれることがあります。  
さて、ビルド(エラーチェック)が完了したら次はマイコンに書き込みます。書いたコードをマイコンに書き込みことで、その指示通りにマイコンが動いてくれます。  
では一体何で書き込むのかというと、ST-Linkで書き込みます。ST-Linkとは、PCと接続して、書いたコードをマイコンに書き込むためのツールです。小泉構文のようになってしまいましたが、それだけ知っていれば十分です。  
ST-LinkとPCを接続するコード(プログラムではなく配線の事)は、主にA to CまたはA to mini-Bです。正しくコードを選んで接続できたら、いよいよ書き込みです。もしも下の画像のように"Reason: No device found on target."と表示されたときは、ST-Linkがうまく認識されていないということです。この場合考えられる原因は、
- PCとの接触不良
- コードが壊れている
- ST-Linkが壊れている
- 基板への電源供給不足  

これらでしょう。マイコンを動かすには、というかLEDを光らせるためにはもちろん動力が必要です。マイコンが載っている基板にある電源ポートにモバイルバッテリーなどをきちんと接続して動かしましょう。そうでないと動きません。著者もこの前やらかしました...。  

![alt text](image-5.png)  

うまく接続できたら、デバッグをして動かします。下の画像のように、画面上部の虫のようなマークをクリックするとデバッグが開始します。デバッグとは、マイコンへ書き込むことを意味します。  

![alt text](image-6.png)  

デバッグが完了したら、下の画像のように、再生ボタンをクリックしてください。そうすれば、基板にあるLEDが順番に光るはずです。



